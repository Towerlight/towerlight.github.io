<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=1, minimum-scale=1, maximum-scale=1">
        <meta name="keywords" content="AMPPZ,OI,">
        <meta name="description" content="AMPPZ 2014 Solution">
        <link rel="stylesheet" href="/css/index.css">
        <link rel="stylesheet" href="/css/github.css">
        <title>AMPPZ 2014 Solution</title>
    </head>
    <body>
        <article class="container">
            <a class="index" href="/">Void Ruin</a>
<ul class="menu">
    <li class="menu-item"><a href="/archive.html">ARCHIVE</a></li>
    <li class="menu-item"><a href="/tag.html">TAG</a></li>
    <li class="menu-item"><a href="/atom.xml">RSS</a></li>
</ul>

            <article class="main article">
                <h1 class="title">AMPPZ 2014 Solution</h1>
                <section class="info">
                    <span class="avatar" style="background-image: url(/images/avatar.jpg);"></span>
                    <a class="name" href="/about.me.html">Falsyta</a>
                    <span class="date" data-time="1446631200">
                        <span class="from"></span>
                        <span class="date" data-time="1446602400">(<span class="from"></span> updated)</span>
                    </span>
                    <span class="tags"><a class="tag" href="/tag/AMPPZ/index.html">AMPPZ</a><a class="tag" href="/tag/OI/index.html">OI</a></span>
                </section>
                <article class="content"><h2>AMPPZ2014 adw</h2>

<p>……签到题。</p>

<pre><code class="language-cpp"># include &lt;cstdio&gt;
# include &lt;algorithm&gt;
using namespace std;
# define REP(i, n) for (int i = 1; i &lt;= n; ++ i)
template &lt;class T0, class T1&gt; inline void RlxN (T0 &amp;x, T1 y) {if (x &gt; y) x = y;}
template &lt;class T0, class T1&gt; inline void RlxX (T0 &amp;x, T1 y) {if (x &lt; y) x = y;}
typedef pair &lt;int, int&gt; pii;
const int inf = 1 &lt;&lt; 30;
int n, m; 
pii minr[30], maxl[30];
int main ()
{
    scanf (&quot;%d%d&quot;, &amp;n, &amp;m);
    int ta, tb, td;
    REP (i, m) minr[i].first = inf, maxl[i].first = -inf;
    REP (i, n) scanf (&quot;%d%d%d&quot;, &amp;ta, &amp;tb, &amp;td), RlxX (maxl[td], pii (ta, i)), RlxN (minr[td], pii (tb, i));
    REP (i, m)
    {
        if (minr[i].first &lt; maxl[i].first) printf (&quot;TAK %d %d\n&quot;, minr[i].second, maxl[i].second);
        else printf (&quot;NIE\n&quot;);
    }
    return 0;
}
</code></pre>

<h2>AMPPZ2014 ben</h2>

<h2>AMPPZ2014 cen</h2>

<h2>AMPPZ2014 dzi</h2>

<p>NlogN 大暴力。</p>

<h2>AMPPZ2014 euk</h2>

<p>显然g.c.d.(p,q)|n才有可能停止游戏。</p>

<p>若p<q，则p的策略是想办法使n>=p，则此时p拿走尽可能多的石子，此后每轮q都只能+q，p只要一直拿即可。
q唯一可能胜利的时候是轮到p时n&lt;p，且在p不断+p的时候q一直拿，并且在p的必胜态前到达0(即(q-p)|n)。</p>

<pre><code class="language-cpp"># include &lt;cstdio&gt;
int gcx (int a, int b) {return !b ? a : gcx (b, a % b);}
bool solve (int n, int p, int q)
{
    return p == q ? true : 
        n % p == 0 ? true :
        p &gt; q ? 
            (n &lt; p ? false : !solve (n % p, q, p)) :
            (n &gt;= p ? true : n % (p - q) &gt; 0);
}
int q0, n, p, q;
int main ()
{
    for (scanf (&quot;%d&quot;, &amp;q0); q0; -- q0) 
    {
        scanf (&quot;%d%d%d&quot;, &amp;p, &amp;q, &amp;n); int d = gcx (p, q); 
        printf (&quot;%c\n&quot;, n % d != 0 ? 'R' : solve (n / d, p / d, q / d) ? 'E' : 'P');
    }
    return 0;
}

</code></pre>

<h2>AMPPZ2014 fil</h2>

<h2>AMPPZ2014 glo</h2>

<h2>AMPPZ2014 hit</h2>

<h2>AMPPZ2014 ins</h2>

<h2>AMPPZ2014 jas</h2>

<p>最后还是去看题解……
定根以后找一个对根来说最宽松的限制，找满足这个限制的离根最近的点显然是对的。</p>

<pre><code class="language-cpp"># include &lt;cstdio&gt;
# include &lt;algorithm&gt;
using namespace std;
# define REP(i, n) for (int i = 1; i &lt;= n; ++ i)
# define REP_G(i, x) for (int i = pos[x]; i; i = g[i].frt)
# define NR 301000
typedef pair &lt;int, int&gt; pii;
struct Edge {int y, frt; void set (int yr, int fr) {y = yr, frt = fr;}} g[NR &lt;&lt; 1];
int n, m, q0, pos[NR], gsz, xM[NR], yM[NR], zM[NR], da[NR], db[NR], dt[NR];
# define v g[i].y
inline void dfs (int x, int fa, int *d) {REP_G (i, x) if (v != fa) d[v] = d[x] + 1, dfs (v, x, d);}
inline void AE (int x, int y) {g[++ gsz].set (y, pos[x]), pos[x] = gsz;}
# define w0 first
# define w1 second
int main ()
{
    for (scanf (&quot;%d&quot;, &amp;q0); q0; -- q0)
    {
        scanf (&quot;%d%d&quot;, &amp;n, &amp;m); int t1, t2;
        REP (i, n) pos[i] = 0; gsz = 0;
        REP (i, n - 1) scanf (&quot;%d%d&quot;, &amp;t1, &amp;t2), AE (t1, t2), AE (t2, t1);
        dt[1] = 0, dfs (1, 0, dt);
        pii ans = pii (-(1 &lt;&lt; 30), 0), p = pii (1 &lt;&lt; 30, 0); bool succ = true;
        REP (i, m) scanf (&quot;%d%d%d&quot;, &amp;xM[i], &amp;yM[i], &amp;zM[i]), ans = max (ans, pii (dt[xM[i]] + dt[yM[i]] - zM[i], i));
        da[xM[ans.w1]] = db[yM[ans.w1]] = 0, dfs (xM[ans.w1], 0, da), dfs (yM[ans.w1], 0, db);
        REP (i, n) if (da[i] + db[i] &lt;= zM[ans.w1]) p = min (p, pii (dt[i], i));
        if (!p.w1) {puts (&quot;NIE&quot;); continue;}
        dt[p.w1] = 0, dfs (p.w1, 0, dt);
        REP (i, m) if (dt[xM[i]] + dt[yM[i]] &gt; zM[i]) {succ = false; break;}
        if (succ) printf (&quot;TAK %d\n&quot;, p.w1);
        else puts (&quot;NIE&quot;);
    }
    return 0;
}
</code></pre>

<h2>AMPPZ2014 kap</h2>

<p>显然对某个点u来说有用的点只有x,y方向上距u最近的点（共四个）。</p>

<pre><code class="language-cpp"># include &lt;cstdio&gt;
# include &lt;cmath&gt;
# include &lt;algorithm&gt;
# include &lt;queue&gt;
using namespace std;
# define REP(i, n) for (int i = 1; i &lt;= n; ++ i)
# define REP_G(i, x) for (int i = pos[x]; i; i = g[i].frt)
# define NR 201000
typedef pair &lt;int, int&gt; pii;
typedef long long ll;
const ll lnf = 1ll &lt;&lt; 61;
struct Edge {int y, frt, w; void set (int yr, int fr, int wr) {y = yr, frt = fr, w = wr;}} g[NR * 4];
struct Poi {int x, y, id;} p[NR];
int n, pos[NR], gsz; ll dt[NR]; bool vis[NR];
priority_queue &lt;pii&gt; Q;
inline void AE (int x, int y, int z) {g[++ gsz].set (y, pos[x], z), pos[x] = gsz;}
bool cmpX (Poi a, Poi b) {if (a.x != b.x) return a.x &lt; b.x; return a.y &lt; b.y;}
bool cmpY (Poi a, Poi b) {if (a.y != b.y) return a.y &lt; b.y; return a.x &lt; b.x;}
inline int cw (int i, int j) {return min (abs (p[i].x - p[j].x), abs (p[i].y - p[j].y));}
# define v g[i].y
ll dijkstra ()
{
    REP (i, n) dt[i] = lnf; Q.push (pii (dt[1] = 0, 1));
    while (!Q.empty ())
    {
        int x = Q.top ().second; Q.pop ();
        if (vis[x]) continue; vis[x] = true;
        REP_G (i, x) if (dt[v] &gt; dt[x] + g[i].w) Q.push (pii (-(dt[v] = dt[x] + g[i].w), v));
    }
    return dt[n];
}
int main ()
{
    scanf (&quot;%d&quot;, &amp;n);
    REP (i, n) scanf (&quot;%d%d&quot;, &amp;p[i].x, &amp;p[i].y), p[i].id = i;
    sort (p + 1, p + n + 1, cmpX);
    REP (i, n - 1) AE (p[i].id, p[i + 1].id, cw (i, i + 1)), AE (p[i + 1].id, p[i].id, cw (i, i + 1));
    sort (p + 1, p + n + 1, cmpY);
    REP (i, n - 1) AE (p[i].id, p[i + 1].id, cw (i, i + 1)), AE (p[i + 1].id, p[i].id, cw (i, i + 1));
    printf (&quot;%lld\n&quot;, dijkstra ());
    return 0;
}
</code></pre>
</article>
                <section class="author">
                    <div class="avatar" style="background-image: url(/images/avatar.jpg);"></div>
                    <a class="name" href="/about.me.html">Falsyta</a>
                    <div class="intro">Too weak</div>
                </section>
                <section class="recommend">
                    
                    
                </section>
                <section id="disqus_thread"></section>
            </article>
        </article>
        <footer class="footer">
    <span class="copyright">
        Void Ruin ©
        <script type="text/javascript">
            document.write(new Date().getFullYear());
        </script>
    </span>
    <span class="publish">Powered by <a href="http://www.inkpaper.io/" target="_blank">Ink</a></span>
</footer>

        <script src="/js/jquery-1.11.2.min.js"></script>
        <script src="/js/highlight.pack.js"></script>
        <script src="/js/jquery.unveil.js"></script>
        <script src="/js/index.js"></script>
        <script type="text/javascript">
            (function() {
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//somebody.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
    </body>
</html>
